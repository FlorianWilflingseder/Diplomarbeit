\section{Umsetzung:}
\subsection*{Frontend:}
\begin{figure}[h!]
    \begin{minipage}[c]{0.5\textwidth}
      \includegraphics[width=\textwidth]{./pics/StartpageBild.png}
      \caption{StartpageBild}
    \end{minipage}
    \begin{minipage}[c]{0.5\textwidth}
      \label{fig:Startpagebild}
      Der Home-Screen basiert auf einem Scroll-View,
      welches den Vorteil bietet ein einheitliches Design auf jeder Art von Bildschrimgröße zu gewährleisten, ohne die Lesbarkeit zu beeinträchtigen. 
      Ein ScrollView in Flutter ist ein Widget, das verwendet wird, um eine Liste von Elementen anzuzeigen, die größer sind als der verfügbare Bildschirm. 
      Es ermöglicht dem Benutzer, durch die Liste zu scrollen, um alle Elemente anzuzeigen. Es gibt verschiedene Arten von ScrollView in Flutter, darunter ScrollView, ListView, GridView und CustomScrollView. Das ScrollView enthält generisch selbst erstellte Objekte names DataCard.
    \end{minipage}
  \end{figure}
  \newpage
  \subsection*{DataCards:}
  \begin{figure}[h!]
    \begin{minipage}[c]{0.5\textwidth}
      \includegraphics[width=\textwidth]{./pics/Bildschirm­foto 2023-03-24 um 16.25.49.png}
      \caption{DataCard}
    \end{minipage}
    \begin{minipage}[c]{0.5\textwidth}
      \label{fig:DataCard}
      Das DataCard Widget in Flutter ist ein vorgefertigtes Material Design-Widget, das zur Darstellung von Informationen in einem Kartenformat verwendet wird. 
      Es besteht aus einer rechteckigen Box mit abgerundeten Ecken, die in der Regel eine Hintergrundfarbe, einen Titel, eine Beschreibung und optional eine Aktion oder einen Button enthält.
      Das DataCard Widget enthält verschiedene Eigenschaften, die angepasst werden können, um das Erscheinungsbild und das Verhalten der Karte zu steuern. Dazu gehören Eigenschaften wie Hintergrundfarbe, Ränder, Schatten, Größe, Padding und Ausrichtung.  
    \end{minipage}
  \end{figure}
DataCards verfügen über die Funktion „onPressed“ in der man angeben kann was geschieht, wenn man eine der 5 DataCards drückt. Wenn man eine DataCard die den Namen „Temperatur“, „Ph-Wert“ oder „Trübung“ drückt wird man an eine weitere Page der App weiter geleitet in der man Statistiken zu dem jeweiligen Wert erhält. Wenn man die DataCard mit dem Namen „Alarm“ drückt wird der Alarm den man erhält wenn verdächtige Bewegungen des Gyroskopssensors wahrgenommen werden aktiviert oder deaktiviert.
Die DataCards auf dem HomeScreen enthalten ansonsten den zuletzt gemessenen Wert, der durch einen WebSocket vom Backend bereitgestellt wird und stellen diesen dar. Die DataCards sind generisch erstellbar mit Übergabewerten, was eine einfache Vergrößerung des Funktionsumfangs des HomeScreens ermöglicht.
Die Icons die auf den DataCards zu sehen sind, werden von Google-Material-Icons bereitgestellt und werden mittels API in die App Ressourceneffizient implementiert.
\begin{figure}[h!]
    \begin{minipage}[c]{0.5\textwidth}
      \includegraphics[width=\textwidth]{./pics/Bildschirm­foto 2023-03-24 um 16.22.40.png}
      \caption{AlarmOFF}
    \end{minipage}
    \begin{minipage}[c]{0.5\textwidth}
      \label{fig:AlarmOFF}
      So sieht die DataCard aus wenn man den Alarm durch drücken des Feldes deaktivert.
    \end{minipage}
\end{figure}
\newpage
\subsection*{Grafische Darstellung der Werte über Zeit:}

\begin{figure}[h!]
    \begin{minipage}[c]{0.4\textwidth}
      \includegraphics[width=\textwidth]{./pics/Diagramme1Bild.png}
      \caption{Diagramme1Bild}
    \end{minipage}
    \begin{minipage}[c]{0.5\textwidth}
      \label{fig:DigrammeApp1}
      Hier sind die Diagramme dargestellt auf die man durch das klicken der DataCards weiter geleitet wird. 
      Sie werden durch die Libraries "charts\_flutter" und "syncfusion\_flutter\_charts" bereitgestellt und mittels
      HTTP-Request befüllt und bei aufruf aktualisiert.

    \end{minipage}
\end{figure}
\begin{figure}[h!]
    \begin{minipage}[c]{0.4\textwidth}
      \includegraphics[width=\textwidth]{./pics/Diagramme2Bild.png}
      \caption{Diagramme2Bild}
    \end{minipage}
    \begin{minipage}[c]{0.5\textwidth}
      \label{fig:DiagrammeApp2}
      Nach dem Freunde Verwandte und Bekannte mittels mündlicher Umfrage befragt wurden, ist beschlossen worden, dass
      Diagramme in den Zeiträumen "24 Stunden", "7 Tage", "1 Monat" und "3Monate" angezeigt werden sollen.
      Diese Zeiträume waren am beliebtesten und sind wenn man die durchschnittliche Dauer einer Badesaison betrachtet am relevantesten
      für den Benutzer dieser Applikation.
    \end{minipage}
\end{figure}
\newpage

\subsection*{Designkonzept:}
Bei dem Design wurde ein sehr schlichtes und leicht zuverstehedes Material-Design gewählt.
Es basiert auf der Schriftart "Poppins-Bold" und macht die App sehr anschaulich. Die Graphen werden bei Aufruf
dynamisch mit den Daten aus der Datenbank befüllt und aktualisiert und dieser Ablauf durch eine Animation in der sich der Graph langsam aufbaut
überbrückt. Die verwendeten Icons werden von Google-Material-Icons bereitgestellt und sind nach belieben veränderbar.
Das Design ist dynamisch und passt sich jeder Bildschrimgröße, Auflösung und Bildschirmverhältnis an.
\begin{figure}[h!]
\begin{minipage}[c]{0.5\textwidth}
\includegraphics[width=\textwidth]{./pics/CodeSnippetChartDesign.PNG}
\caption{CodeSnippetChartDesign}
\end{minipage}
\begin{minipage}[c]{0.5\textwidth}
    \label{fig:CodeSnippetGraph}
    Dieses Code-Snippet zeigt einen kleinen Einblick wie man einen Graphen designed und mit seinen dazugehörigen 
    Daten befüllt. Ein Graph braucht eine bestimtme Art von Liste durch die er befüllt wird. Die Daten 
    die sich in dieser Liste befinden werde vorher von der Logik durch die HTTP-Request abgefragt und für jeden Graphen einzeln
    aufbereitet um die Daten anschaulich darzustellen.
\end{minipage}
\end{figure}
\newline 
Da der die Sinus-Grpahen jedem Tag nur einen druchschnitts Wert zuordnen um somit die Darstellung übersichtlicher
zu gestalten wird davor für jeden Tag ein Durschnittswert berechnet. Da das Backend um Bits zu sparen nur einen Epoch-Timestamp übergibt
muss dies auch vorher aufbereitet werden.


\newpage
\subsection*{Umsetzung Backend:}
\subsubsection*{Generelle Funktionsweise:}
Die generelle Funktionsweise des Backends basiert auf zwei TTGO-ESP32-LoRa  \newline Mikroprozessoren. 
Einer dieser Mikrochips(Sender) hat 4 verbaute Sensoren darunter:

\begin{itemize}
  \item Temperatursensor
  \item Ph-Sensor
  \item NTU-Trübungssensor
  \item Beschleunigungssensor  
\end{itemize}

Die Sensoren wurden über die vom ESP32 zur Verfügung gestellten Pins angelötet. 
Der Trübungssensor wurde bei einem ADC-Pin (Analog-Digital-Converter) angelötet, 
ebenso wie der Ph-Sensor, der Temperatursensor ist bei einem GPIO (General Purpose Input/Output) angebracht und der Beschleunigungssensor bei einem SDA(serial data) und dem SCL(serial clock) Anschluss. 
Der ESP32(Sender) wird alle 3 Stunden aus seinem Sleep-Zustand aufgeweckt und nimmt eine Messung der Daten vor. Er befindet sich während er inaktiv ist im Sleep damit er noch Stromsparender agiert da er nicht an einer Steckdose angebracht ist sondern mit einer externen Batterie betrieben wird.
Diese Daten werden direkt nach der Messung an den anderen ESP32(Reciever) gesendet. 
Die Daten werden nicht auf dem im Wasser schwimmenden Sender gespeichert da dieser äußerst stromsparend vorgehen soll. 
Die Messwerte werden mittels LoRa-Funk-System welches lokal an dem ESP32 verbaut ist an den Reciever gesendet und dort bei Erhalt mit einem Epoch-Timestamp versehen und in das SPIFF-File-System gespeichert. 
Das äußerst kleine Speichersystem ermöglicht eine Speicherung der Daten in einem Intervall von allen 3 Stunden über 1 Jahr durchgehend. 
Die Daten werden mittels Web-Sockets(für die Live-Daten-Aktualisierung) bereitgestellt und mit einem http-Request der alle Daten an das Frontend übergibt falls das Fenster mit den Zeit-Diagrammen aufgerufen wird um sie in die jeweiligen Diagramme einzufügen. 
Die dazu benötigten Libraries um dies alles in C umzusetzen sind unter „Technologien| Software“ zu finden. 

\newpage
Die Daten die für eine Routine-Übertragung alle 3 Stunden nötig sind, lauten:

\begin{itemize}
  \item Datum
  \item Temperatur
  \item Ph-Wert
  \item NTU-Wert
\end{itemize}

Die Daten des Beschleunigungssensors werden nicht übertragen, um Speicherplatz zu sparen, die Aktualisierungsgeschwindigkeit 
zu erhöhen und eine Echt-Zeit-Benachrichtigung zu ermöglichen, sondern der Sender sendet eine extra Benachrichtigung falls 
der Beschleunigungssensor Werte erreicht hat die auf verdächtige Aktivitäten im Wasser hinweisen. 
Der (Reciever) ESP32 ist  mit dem W-Lan verbunden und permanent eingeschaltet um die Daten 24 Stunden 7 Tage 
in der Woche zu erhalten zu verarbeiten und für das Frontend für eine http-Request bereitzustellen. 

\begin{figure}[b]
  \centering
  \includegraphics[width=0.8\textwidth]{./pics/Aufbau_Diplomarbeit.png}
  \caption{Funktionsweise der Datenübertragung}
  \label{fig:Datenübertragung}
\end{figure}

\newpage
\subsubsection*{Funktion von LoRa in diesem Projekt:}

Die Kommunikationstechnologie, die auf der Basis von Spread-Spectrum-Techniken entwickelt wurde ermöglicht eine drahtlose 
Kommunikation über große Entfernungen bei niedriger Leistungsaufnahme. 
In deinem Fall werden die Daten von drei Sensoren (Temperatursensor, pH-Sensor und NTU-Trübungssensor) mithilfe eines \newline ESP32-Mikrocontrollers und eines LoRa-Transceivers an einen zweiten ESP32, der als Empfänger fungiert, übertragen.


Hier ist das Grundkonzept, wie LoRa funktioniert und die Daten überträgt:

\begin{itemize}
  \item Sensoren erfassen Daten: Die drei Sensoren (Temperatur, pH und NTU-Trübung) erfassen Umgebungsdaten und übermitteln diese an den ESP32-Mikrocontroller.
  \item Datenverarbeitung: Der ESP32-Mikrocontroller verarbeitet die empfangenen Daten, konvertiert sie in ein geeignetes Format und erstellt ein Datenpaket. Dieses Paket enthält die Sensordaten.
  \item LoRa-Modulation: Der LoRa-Transceiver, der am ESP32 angeschlossen ist, wandelt das Datenpaket in ein Funksignal um, das für die Übertragung über das LoRa-Protokoll geeignet ist. LoRa verwendet eine Chirp Spread Spectrum (CSS)-Technologie, bei der die Frequenz des Funksignals kontinuierlich über eine bestimmte Bandbreite variiert. Diese Technik erhöht die Störfestigkeit und ermöglicht eine effiziente Nutzung des Funkspektrums.
  \item Datenübertragung: Das modulierte Funksignal wird über die LoRa-Antenne ausgesendet und kann über große Entfernungen übertragen werden. LoRa ist besonders für Anwendungen mit geringem Energieverbrauch und geringer Datenrate geeignet.
  \item Empfang des Funksignals: Der zweite ESP32, der als Empfänger fungiert, ist ebenfalls mit einem LoRa-Transceiver und einer Antenne ausgestattet. Dieser empfängt das Funksignal, das von der Senderantenne ausgesendet wurde.
  \item Demodulation und Datenextraktion: Der LoRa-Transceiver am Empfänger demoduliert das empfangene Funksignal und extrahiert das ursprüngliche Datenpaket. Dabei wird die Spread-Spectrum-Technik rückgängig gemacht, um die übertragenen Informationen zurückzugewinnen.
  \newpage
  \item Datenverarbeitung: Der empfangende ESP32-Mikrocontroller verarbeitet das extrahierte Datenpaket, um die Daten der einzelnen Sensoren (Temperatur, pH und NTU-Trübung) zu erhalten. Anschließend werden die Daten dann für die Zugriffe des Frontends vorbereitet.
\end{itemize}

\subsection*{Reciever:}


\begin{lstlisting}[language=C, caption={Reciever sendet von LoRa erhaltene Daten an Clients}, label={lst:Reciever}]
  for (;;) {
        lora_receive();

        // CURRENT_EPOCH - TIMESTAMP
        // 0, 1, 2, 3, ....
        while (lora_received()) {
            x = lora_receive_packet(buf, sizeof(buf));
            buf[x] = 0;
            char *newB = (char*)buf;
            char str[256];
            sprintf(str, "%lld;", asd + time(0));

            prepend(newB, str);

            printf("rec: %s\n", newB);

            // timestamp;ph;ntu;temp

            fprintf(fp, "%s\n", newB);
            fflush(fp);

            size_t clients = max_clients;
            int client_fds[max_clients];
            
            if (httpd_get_client_list(server, &clients, client_fds) == ESP_OK) {
                for (size_t i = 0; i < clients; ++i) {
                    int sock = client_fds[i];

                    if (httpd_ws_get_fd_info(server, sock) == HTTPD_WS_CLIENT_WEBSOCKET) {
                        ESP_LOGI(TAG, "Active client (fd=%d) -> sending async message", sock);
                        
                        struct async_resp_arg *resp_arg = malloc(sizeof(struct async_resp_arg));
                        resp_arg->hd = server;
                        resp_arg->fd = sock;
                        resp_arg->buf = (char*)buf;
                        
                        if (httpd_queue_work(resp_arg->hd, send_data, resp_arg) != ESP_OK) {
                            ESP_LOGE(TAG, "httpd_queue_work failed!");
                            break;
                        }
                    }
                }
            } else {
                ESP_LOGE(TAG, "httpd_get_client_list failed!");
            }

            lora_receive();
        }
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
\end{lstlisting}
In diesem Ausschnitt des Reciever-Codes wird lora\_recieve() gestartet. 
Dadurch wartet der Empfänger auf ein LoRa-Datenpacket. 
Wenn ein Datenpacket Empfangen wird, wird die „while-Schleife“ ausgeführt und die Packete in den Buffer gelesen und ein Epoch-Timestamp vorne daran gehängt. Danach werden die Daten in den File geschrieben. Dann werden alle Web-Server-Clients abgefragt und die neuen Daten an sie gesendet. Dies wird in der „for-Schleife“ für jeden einzelnen Client wiederholt. Wenn der Client einen Web-Socket ist wird ein anderer Code ausgeführt aber in beiden Fällen werden die Daten an den Client gesendet.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.4\textwidth]{./pics/Reciever Struktur.png}
  \caption{Reciever Struktur}
  \label{fig:Reciever Datei-Struktur}
\end{figure}
In Wifi.c wird das Wifi-Library eingebunden. In Wifi.h werden die Daten des Routers eingetragen(SSID und Passwort), lora.c ist das Lora Library welche beide in main.c benutzt werden.

\newpage
\subsection*{Sender:}
\begin{lstlisting}[language=C, caption={Sender lest die Daten der Sensoren aus und überträgt sie via LoRa}, label={lst:Sender}]
  void
  sensors_task(void *p)
  {
      int raw;
      float pH = 0, ntu = 0, temp = 0;
      char str[64];
  
      for(;;) {
          ESP_ERROR_CHECK(adc_oneshot_config_channel(adc2_handle, PH_SENSOR_ADC2_CHANNEL, &chan_cfg));
          ESP_ERROR_CHECK(adc_oneshot_read(adc2_handle, PH_SENSOR_ADC2_CHANNEL, &raw));
          pH = raw * (5.0 / 1024);
          pH *= 2;
  
          esp_err_t err = ds18b20_set_resolution(handle, NULL, DS18B20_RESOLUTION_12B);
          if (err != ESP_OK) {
              ESP_LOGI(TAG, "failed to set res");
          }
          err = ds18b20_trigger_temperature_conversion(handle, NULL); 
          if (err != ESP_OK) {
              ESP_LOGI(TAG, "failed to trigger temp conversion");
          }
          
          vTaskDelay(pdMS_TO_TICKS(800));
  
          // 5YSq5pyI44G+44KK44Gq base64
  
          for (int i = 0; i < device_num; ++i) {
              float newTemp;
              err = ds18b20_get_temperature(handle, device_rom_id[i], &newTemp);
              if (err != ESP_OK) {
                  continue;
              }
  
              if (newTemp != 0) {
                  temp = newTemp;
              }
          }
  
          ESP_ERROR_CHECK(adc_oneshot_config_channel(adc2_handle, NTU_SENSOR_ADC2_CHANNEL, &chan_cfg));
          ESP_ERROR_CHECK(adc_oneshot_read(adc2_handle, NTU_SENSOR_ADC2_CHANNEL, &raw));
          ntu = raw * (5.0 / 1023);
          ntu /= 20;
  
          snprintf(str, 64, "%.2f;%.2f;%.2f", pH, ntu, temp);
  
          printf("SENT %s\n", str);
          lora_send_packet((uint8_t*)str, 64);
  
          vTaskDelay(pdMS_TO_TICKS(DELAY));
      }
  
  
      ESP_ERROR_CHECK(onewire_del_bus(handle));
      ESP_LOGI(TAG, "1-wire bus deleted");
  
      ESP_ERROR_CHECK(adc_oneshot_del_unit(adc2_handle));
  } 
\end{lstlisting}
In diesem Code-Ausschnitt werden die Sensoren an ihren jeweiligen Pins ausgelesen und der zurückgegebene Referenzwerte in die jeweilige Einheit umgerechnet. 
Daraufhin werden Sie in einen char-Array(String) geladen und in ein LoRa-Packet gepackt und versendet.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.4\textwidth]{./pics/Sender Struktur.png}
  \caption{Sender Struktur}
  \label{fig:Sender Datei-Struktur}
\end{figure}

ds18b20.c und onewire\_bus.c sind die Libraries für den Temperatursensor, lora.c das Library für LoRa, in sensors.c befindet sich der Code für alle Sensoren
sowie der oben gezeigt Code-Ausschnitt. In main.c wird LoRa und die Sensoren initialisiert. 